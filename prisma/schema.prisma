// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider        = "prisma-client-js" 
  // Specifies that Prisma should generate a JavaScript/TypeScript client for interacting with the database.
  previewFeatures = ["driverAdapters"]
  // Enables experimental features in Prisma, like driver adapters, which can be used for custom database drivers or advanced configurations. 
}

datasource db {
  provider  = "postgresql" 
  // Indicates that the database being used is PostgreSQL.
  url       = env("POSTGRES_PRISMA_URL") 
  // References an environment variable that holds the connection string for PostgreSQL with 'connection pooling', optimizing for serverless environments. Connection pooling refers to a technique used to manage database connections efficiently by reusing a pool of active connections instead of opening a new connection every time the application needs to interact with the database.
  directUrl = env("POSTGRES_URL_NON_POOLING") 
  // References a different environment variable for a direct connection string to PostgreSQL without connection pooling.
}


// Having both a url with connection pooling and a directUrl with a direct connection that doesn’t use connection pooling allows for flexibility in how the application connects to the database, depending on the environment or specific needs of the application.

// Here’s why you might want both:

// 	1.	Serverless Environments vs. Traditional Environments:
// 	•	In serverless or edge environments, where connections are frequently opened and closed, connection pooling is critical to avoid exhausting the database’s connection limit and to improve performance. The url with connection pooling is used in these cases to manage connections efficiently.
// 	•	In more traditional server environments or during local development, where the application might have fewer instances and a more predictable connection pattern, a direct connection might be preferred. The directUrl allows a straightforward, one-to-one connection to the database without the overhead of managing a connection pool.
// 	2.	Failover or Debugging:
// 	•	Having both options can be useful for failover or debugging purposes. If there are issues with the connection pool (e.g., it’s not behaving as expected), you can switch to a direct connection using the directUrl to bypass the pooling logic and troubleshoot the issue more easily.
// 	3.	Performance Tuning:
// 	•	There might be scenarios where you want to tune performance by testing both pooled and non-pooled connections to see which performs better under certain loads or conditions. This flexibility allows you to choose the best approach for different stages of development, testing, or deployment.
// 	4.	Legacy or Compatibility Reasons:
// 	•	Some legacy systems or certain parts of the application might not be compatible with connection pooling, so having a directUrl provides a fallback option.

// model User defines a User table in the database.
model User {  
  id            String          @id @default(cuid())
  // // Primary key with a unique identifier generated by the cuid() function.
  name          String?
  email         String          @unique
  emailVerified DateTime?
  image         String?
  // Fields for storing user details. email is unique.
  accounts      Account[]
  sessions      Session[]
  // Relations to the Account and Session models, creating a one-to-many relationship.
 
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  // createdAt, updatedAt: Timestamp fields that are automatically managed by Prisma, with createdAt set at creation and updatedAt updated on each change.

  @@map("users")
}
 
// Defines an Account table that links to the User table. 
model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  // userId, type, provider, providerAccountId: Fields for storing account details, with a composite primary key on provider and providerAccountId.
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  // refresh_token, access_token, etc.: Fields for storing tokens and other authentication data.
 
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  // createdAt, updatedAt: Timestamp fields.
 
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  // user: Relation to the User model, establishing a foreign key (userId) and cascading deletes if the related user is deleted.

  @@id([provider, providerAccountId])
  @@map("accounts")
}
 
// Defines a Session table that also links to the User table.
model Session {
  sessionToken String   @unique
  userId       String
  expires      DateTime
  // sessionToken, userId, expires: Fields for storing session details, with sessionToken being unique.
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  // user: Relation to the User model, with cascading deletes.
 
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  // createdAt, updatedAt: Timestamp fields.

  @@map("sessions")
}
 
// Defines a VerificationToken table for handling verification tokens.
model VerificationToken {
  identifier String
  token      String
  expires    DateTime
  // identifier, token, expires: Fields for storing verification token details.
 
  @@id([identifier, token])
  // @@id([identifier, token]): Composite primary key on identifier and token.

  @@map("verification_tokens")
}
